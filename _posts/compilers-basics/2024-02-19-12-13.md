---
title:  "12-13: Code Generation"
layout: post
categories: compilers-basics
---

# 12-01: Introduction to Code Generation
1. The accumulator is kept in MIPS register **$a0**;
2. The address of the next location on the stack is kept in MIPS register **$sp**:
  - The top of the stack is at address **$sp + 4**.
3. **lw r1 offset(r2)**:
  - Load 32-bit word from address **r2 + offset** into **r1**.
4. **add r1 2r r3**:
  - **r1 <- r2 + r3**.
5. **sw r1 offset(r2)**:
  - Store 32-bit word in **r1** at address **r2 + offset** into.
6. **addiu r1 r2 i**:
  - **r1 <- r2 + i**.
7. **li r i**:
  - **r <- i**.

# 12-02: Code Generation I
1. **beq r1 r2 label**:
  - Branch to label if **r1 = r2**.
2. **b label**:
  - Unconditional jump to label.

# 12-03: Code Generation II
1. **jal label**:
  - Jump to label, save address of next instruction in **$ra**.
2. **jr r**:
  - Jump to address in register **r**.

# 12-05: Temporaries
1. Let **NT(e) = #** of temps needed to evaluate **e**;
2. **NT(e1 + e2)**:
  - Needs at least as many temps as **NT(e1)**;
  - Needs at least as many temps as **NT(e2) + 1**.
3. Space used for temps in **e1** can be reused for temps in **e2**;
4. Code generation must know how many temporaries are in use at each point;
5. Add a new argument to code generation:
  - the position of the next available temporary.
6. The temporary is used like a small, fixed-size stack.

# 12-06: Object Layout
1. Objects are laid out in contiguous memory;
2. Each attribute stored at a fixed offset in the object:
  - The attribute is in the same place in every object of that class.
3. When a method is invoked, the object is **self** and the fields are the object's attributes;
4. The offset for an attribute is the same in a class and all of its subclasses;
5. Every class has a fixed set of methods:
  - Including inherited methods.
6. A **dispatch table** indexes these methods:
  - An array of method entry points;
  - A method **f** lives at a fixed offset in the dispatch table for a class and all of its subclasses.

# 13-01: Semantics Overview
1. **Operational semantics** describes program evaluation via execution rules on an abstract machine;
2. **Denotational semantics**:
  - Program's meaning is a mathematical function.
3. **Axiomatic semantics**:
  - Program behavior described via logical formulas.

# 13-02: Operational Semantics
1. A variable environment maps variables to locations:
  - Keeps track of which variables are in scope;
  - Tells up where those variables are.
