---
title:  "SOE.YCSCS1 16-17: Register Allocation and Memory Management"
layout: post
categories: compilers-basics
---

# 16-01: Register Allocation
1. Temporaries **t1** and **t2** can share the same register if at any point in the program at most one of **t1** or **t2** is live;
2. Construct an undirected graph:
  - A node for each temporary;
  - An edge between **t1** and **t2** if they are live simultaneously at some point in the program.
3. This is the **register interference graph** (RIG):
  - Two temporaries can be allocated to the same register if there is no edge connecting them.

# 16-02: Graph Coloring
1. A **coloring of a graph** is an assignment of colors to nodes, such that nodes connected by an edge have different colors;
2. A graph is **k-colorable** if it has a coloring with k colors;
3. The following works well in practice:
  - Pick a node **t** with fewer than **k** neighbors;
  - Put **t** on a stack and remove it from the RIG;
  - Repeat until the graph is empty.
4. Assign colors to nodes on the stack:
  - Start with the last node added;
  - At each step pick a color different from those assigned to already colored neighbors.

# 16-03: Spilling
1. Pick a node (**f**) as a candidate for spilling;
2. Remove **f** and continue the simplification;
3. Eventually we must assign a color to **f**;
4. We hope that among the **k** neighbors of **f** we use less than **k - 1** color -> **optimistic coloring**;
5. if optimistic coloring fails, we spill **f**:
  - Allocate a memory location for **f**;
6. Spilling reduces the live range of **f**:
  - And thus reduces its interferences;
  - Which results in fewer RIG neighbors.
7. Additional spills might be required before a coloring is found;
8. Heuristics what to spill:
  - Spill temporaries with most conflicts;
  - Spill temporaries with few definitions and uses;
  - Avoid spilling in inner loops.

# 16-04: Managing Caches
**Loop interchange** optimization.

# 17-01: Automatic Memory Management
1. **Observation**: a program can use only the objects that it can find;
2. Every GC scheme has the following steps:
  - Allocate space as needed for new objects;
  - When space runs out:
    1. Compute what objects might be used again(generally by tracing objects reachable from a set of "root" registers);
    2. Free the space used by objects not found in the previous step.

# 17-02: Mark and Sweep
1. When memory runs out, GC executes two phases:
  - the **mark** phase: traces reachable objects;
  - the **sweep** phase: collect garbage objects.
2. Every object has an extra bit: the mark bit:
  - reserved for memory management;
  - initially the mark bit is 0;
  - set to 1 for the reachable objects in the mark phase.
3. Space for a new object is allocated from the free list:
  - a block large enough is picked;
  - an area of the necessary size is allocated from it;
  - the left-over is put back in the free list.
4. Mark and Sweep can fragment the memory.

# 17-03: Stop and Copy
1. Memory is organized into two areas:
  - **old space**: used for allocation;
  - **new space**: used as a reserve for GC.
2. The heap pointer points to the next free word in the old space;
3. Allocation just advances the heap pointer;
4. GC starts when the old space is full;
5. Copies all reachable objects from old space into new space:
  - garbage is left behind;
  - after the copy phase the new space uses less space than the old one before the collection.
6. After the copy the roles of the old and new spaces are reversed and the program resumes;
7. As we copy an object we store in the old copy a **forwarding pointer** to the new copy:
  - when we later reach an object with a forwarding pointer we know it was already copied.
8. We still have the issue of how to implement the traversal without using extra space:
  - partition the new space in three contiguous regions:
    1. **copied and scanned**: copied objects whose pointer fields have been followed;
    2. **copied**: copied objects whose pointer fields have not been followed yet;
    3. **empty**.
9. **Algorithm**:
  - **Step 1**: Copy the objects pointed to by roots and set forwarding pointers;
  - **Step 2**: Follow the pointer in the next unscanned object (*A*):
   1. copy the pointed-to objects;
   2. fix the pointer in *A*;
   3. set forwarding pointer.
  - Each object is processed entirely before any objects it points to.
10. **Stop and Copy** is generally believed to be the fastest GC technique.

# 17-04: Conservative Collection
1. If a memory word looks like a pointer it is considered a pointer:
  - it must be aligned;
  - It must point to a valid address in the data segment.
2. All such pointers are followed and we overestimate the set of reachable objects.

# 17-05: Reference Counting
1. Store in each object the number of pointers to that object:
  - this is the reference count.
2. Each assignment operation manipulates the reference count;
3. **Advantages**:
  - easy to implement;
  - collect garbage incrementally without large pauses in the execution.
3. **Disadvantages**:
  - cannot collect circular structures;
  - manipulating reference count at each assignment is very slow.
